/*from to
311  14 Non-visible part of the top of the screen / Non-visible part of the upper border (16 lines)
 15  50 Visible part of the upper border (36 lines)
 51 250 Regular (and visible, doh!) part of the display / Screen background (200 lines)
251 299 Visible part of the lower border (49 lines)
300 302 Visible part of the vertical blanking interval (VBI) / Very bottom of the visible screen  (3 lines)
303 310 Non-visible part of the vertical blanking interval (VBI) (8 lines)
*/

/* https://lemonspawn.com/turbo-rascal-syntax-error-expected-but-begin/turbo-rascal-se-tutorials/tutorial-8-full-screen-smooth-scrolling-know-your-timing-banking/ */
/* http://1amstudios.com/2014/12/07/c64-smooth-scrolling*/
/* https://www.pagetable.com/c64ref/6502/?tab=2#STA */

program SplitScroller;
@use "input/key"
var

	const first_vis_line : byte = 50;
	const start_colorcopy_line : byte = 65;
	const begin_vblank_line : byte = 245;

	@define useKernal "0"

	val, row, col, startrow, endrow, screen_buffer_num : byte = 0;
	this_color, this_char : byte = 1;
	scroll : byte = 7;

	screen_base : integer = $0400;
	screen_backbuffer_base : integer = $0800;
	
	caddr : array[25] of integer;
	
interrupt irq_begin_vblank();
procedure screen_swap();
procedure copy_colors(ul:byte);
procedure swap_screens();
procedure DrawColumn39();

// Line 65
interrupt irq_line_65;
begin
	
	StartIRQ(@useKernal);

	if scroll = 0 then
	begin
		copy_colors(0); // color_shift_upper
	end;	

	RasterIRQ(irq_begin_vblank(), begin_vblank_line, @useKernal);

	CloseIRQ();

end;

// vblank line starts at 245
interrupt irq_begin_vblank;
begin
	
	StartIRQ(@useKernal);
	
	dec(scroll);
	
	if (scroll <= 127) then
	begin
		swap_screens();
	end;	
	
	scrollx(scroll);
	
	if (scroll = 4) then
	
	CloseIRQ();

end;

procedure swap_screens();
begin
	scroll := 7;
	scrollx(scroll);
	screen_swap();	
	copy_colors(1); // color_shift_lower
	DrawColumn39();
end;

procedure screen_swap();
begin
	
screen_buffer_num := (screen_buffer_num + 1) & 1;	// Flip between 0 and 1

	if screen_buffer_num = 0 then
	begin
		screen_base := $0400;
		screen_backbuffer_base := $0800;			
	end;	
	
	if screen_buffer_num = 1 then
	begin
		screen_base := $0800;
		screen_backbuffer_base := $0400;			
	end;
	

end;

procedure copy_colors(ul : byte);
begin
	
	if ul = 0 then
	begin
		startrow := 0;
		endrow := 12;
	end
	else
	begin
		startrow := 13;
		endrow := 24;		
	end;
	
	fori row := startrow to endrow do 
	begin
		for col := 0 to 39 do
		begin
			// col, row
			colormemory := AddressTable( #caddr, col, row );
			colormemory[0] := colormemory[1];
		    colormemory[1] := this_color;
		end;
	end;

	inc(this_color);
	if this_color > $A then this_color := 1;	

end;

procedure DrawColumn39();
begin

	
	val := hi(screen_base);						// $0400 or $4400

	this_char := 1;
	moveto(0, 0, val);		// ScreenMemory pointer to x, y, address high
	for row := 0 to 25 do begin
		screenmemory[39] := this_char;
		screenmemory := screenmemory + screen_width;
		inc(this_char);
		if this_char > 10 then this_char := 1;
		//addbreakpoint();
	end;
		
end;

procedure screen_shift(ul_:byte);
begin
	
	
	if ul_=0 then
		// Copy bottom half to other buffer shifted left by 1
		copyhalfscreen(#screen_base, #screen_backbuffer_base -^1, 13, 1,0);
	else
		// Copy top half to other buffer shifted left by 1
		copyhalfscreen(#screen_base + ^520, #screen_backbuffer_base -^1 + ^520, 13, 1,0)
	end;


end;

begin
	CreateAddressTable( #caddr, $D800, 40, 25 );   // $D800 color address, 40 characters per column, 25 rows
	DefineScreen();
	SetMemoryConfig(1, @useKernal, 0);
	StartRasterChain(irq_line_65(), start_colorcopy_line, @useKernal);
	Loop();

end.
